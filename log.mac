; vim: ft=nasm

%ifndef _logasm_log_mac_
%define _logasm_log_mac_

section .bss
  LINEBUFFER resb 32

section .text
  DEBUG:        db 27,"[0;34mDEBUG ",27,"[0m"
  DEBUG_LEN     equ $-DEBUG
  INFO:         db 27,"[0;32mINFO  ",27,"[0m"
  INFO_LEN      equ $-INFO
  WARN:         db 27,"[0;91mWARN  ",27,"[0m"
  WARN_LEN      equ $-WARN
  ERROR:        db 27,"[0;31mERROR ",27,"[0m"
  ERROR_LEN     equ $-ERROR
  LOCATION:     db 27,"[0;90m"
  LOCATION_LEN  equ $-LOCATION
  NEWLINE       db 10
  NEWLINE_LEN   equ $-NEWLINE
  COLON:        db ":"
  COLON_LEN     equ $-COLON
  ATLOC:        db " at"
  ATLOC_LEN     equ $-ATLOC

; functions documented, maintained and tested in ./lib
; included here in order to make this macro file standalone
; without the need to link extra object files

; ./lib/hex2decimal.asm
hex2decimal:

  push eax
  push ebx
  push ecx

  mov ebx, 10             ; base is 10
  mov ecx, esi            ; remember end of string
.convert:
  xor edx, edx            ; clear edx
  div ebx                 ; -> quotient in eax, remainder in edx

  add dl, '0'             ; make printable
  cmp dl, '9'             ; is it a hex digit?
  jbe .store              ; if not store as is

  add dl, 'A' - '0' - 10  ; adjust hexdigit

.store:
  dec esi                 ; move back one position
  mov byte [esi], dl      ; store converted digit
                          ;   stosb would be faster here, but then we'd need to
                          ;   rearrange which is in what register which also takes time
  and eax, eax            ; did division result in 0?
  jnz .convert            ; if not keep converting

  sub ecx, esi            ; calculate length of string
  mov edx, ecx            ; sys_write expects length in edx

  pop ecx
  pop ebx
  pop eax

  ret

; ./lib/strlen.asm
strlen:

  push  eax
  push  ecx
  push  edi

  xor   eax, eax          ; we are searching for 0
  mov   ecx, 0000ffffh    ; expecting strings no longer than 65535 bytes
  cld                     ; search upwards in memory

  repne scasb             ; read starting at edi until we find 0 or run out of bytes
  jnz    .fail

  mov   edx, 0000fffeh    ; ecx was decremented each time (one too many since it includes 0 terminator)
  sub   edx, ecx          ; so substracting from original (ecx - 1) gets us the string length

  pop   edi
  pop   ecx
  pop   eax

  ret

.fail:
  mov eax, 4              ; log error
  mov ebx, 1
  mov ecx, ENDNOTFOUNDMSG
  mov edx, ENDNOTFOUNDLEN
  int 80H

  mov eax, 1              ; exit with code 1
  mov ebx, 1
  int 80H

section .data
  ENDNOTFOUNDMSG: db "FATAL: Unable to find end of string, max size exceeded"
  ENDNOTFOUNDLEN  equ $-ENDNOTFOUNDMSG

%macro log_text 0
  LOG__FILE:     db " ", __FILE__,0
  LOG__FILE_LEN  equ $-LOG__FILE
%endmacro

%macro log__push_all 1-*
  %rep %0
    push %1
    %rotate 1
  %endrep
%endmacro

%macro log__pop_all 1-*
  %rep %0
    %rotate -1
    pop %1
  %endrep
%endmacro

%macro log__sys_write 2 ;(s, len)
  log__push_all eax, ebx, ecx, edx
  mov eax, 4
  mov ebx, 1
  mov edx, %2
  mov ecx, %1
  int 80H
  log__pop_all eax, ebx, ecx, edx
%endmacro

%macro log__location 0
  log__push_all eax, ebx, ecx, edx, esi

  log__sys_write LOCATION, LOCATION_LEN
  log__sys_write ATLOC, ATLOC_LEN
  log__sys_write LOG__FILE, LOG__FILE_LEN
  log__sys_write COLON, COLON_LEN

  mov eax, __LINE__
  mov esi, LINEBUFFER + 32
  call hex2decimal

  ; write out lineno which is @edx
  mov eax, 4
  mov ebx, 1
  mov ecx, esi
  int 80H

  log__pop_all eax, ebx, ecx, edx, esi
%endmacro

%macro log_debug 2
  log__sys_write DEBUG, DEBUG_LEN
  log__sys_write %1, %2
  log__location
  log__sys_write NEWLINE, NEWLINE_LEN

%endmacro

%macro log_debug 1
  log__push_all edi, edx
  mov edi, %1
  call strlen
  log_debug %1, edx
  log__pop_all edi, edx
%endmacro

%macro log_info 2
  log__sys_write INFO, INFO_LEN
  log__sys_write %1, %2
  log__location
  log__sys_write NEWLINE, NEWLINE_LEN
%endmacro

%macro log_info 1
  log__push_all edi, edx
  mov edi, %1
  call strlen
  log_info %1, edx
  log__pop_all edi, edx
%endmacro

%macro log_warn 2
  log__sys_write WARN, WARN_LEN
  log__sys_write %1, %2
  log__location
  log__sys_write NEWLINE, NEWLINE_LEN
%endmacro

%macro log_warn 1
  log__push_all edi, edx
  mov edi, %1
  call strlen
  log_warn %1, edx
  log__pop_all edi, edx
%endmacro

%macro log_error 2
  log__sys_write ERROR, ERROR_LEN
  log__sys_write %1, %2
  log__location
  log__sys_write NEWLINE, NEWLINE_LEN
%endmacro

%macro log_error 1
  log__push_all edi, edx
  mov edi, %1
  call strlen
  log_error %1, edx
  log__pop_all edi, edx
%endmacro

%endif
